% -*- mmm-noweb-code-mode: awk-mode -*-
 
\documentclass[12pt]{article}

%{{{ Preamble

\usepackage{mathptmx}
\usepackage[margin=1in]{geometry}
\usepackage[longchunks,breakcode]{knoweb}
\usepackage{fancyvrb,syntax}
\usepackage{ifpdf,xspace}

\ifpdf
  \usepackage[pdftex,colorlinks,backref,bookmarks
  ,pdftitle={Awk Filters for Automatically Indexing Noweb Source Files}
  ,pdfauthor={Joseph Riel}
  ,pdfpagemode={UseOutline}
  ,bookmarksopen={true}
  ]{hyperref}
\else
  \usepackage[dvips,backref]{hyperref}
\fi

\newcommand{\bs}{\textbackslash}
\newcommand{\comment}[1]{\textcolor{red}{\emph{#1}}}
\newcommand{\package}[1]{\textsf{#1}\xspace}
\newcommand{\file}[1]{\textsf{#1}\xspace}
\newcommand{\env}[1]{\textsf{#1}\xspace}
\newcommand{\cmd}[1]{\textsf{#1}\xspace}

\newcommand{\noweb}{\package{noweb}\xspace}
\newcommand{\noweave}{\package{noweave}\xspace}
\newcommand{\notangle}{\package{notangle}\xspace}

\newcommand{\gawk}{\cmd{awk}}

\pagestyle{noweb}

% Adjust float placement

\renewcommand{\bottomfraction}{0.5}

%}}}

\title{Awk Filters for Automatically Indexing \\ Noweb Source Files}
\author{Joseph S. Riel}
\date{1 February 2008}

\begin{document}

\maketitle

%{{{ Introduction

\section{Introduction}
\label{sec:introduction}


The \noweb system of literate programming
uses a pipeline approach that permits 
users to insert filters to modify its behaviour.
Ramsey~\cite{ramsey01:NowebHackersGuide} describes in detail the pipeline
and its markup language.
Distributed with the package are filters
for automatically indexing symbols for several languages.

This package contains the source for a generic filter
for indexing any source.  Two variables must be
assigned to do the actual indexing:
  a regular expression that matches the line to index,
  and an integer that selects which subgroup in 
  the regular expression contains the symbol to index.
Four shell scripts are provided that define the appropriate
variables for indexing Elisp, Maple, Matlab, and Python sources.

%}}}

\section{Generic Filter}

The generic filter is an executable \gawk script.

<<autodefs.generic>>=
<<pound-bang>>
<<generic header>>
<<generated file warning>>
<<copyright>>
BEGIN {
    <<check for [[regex]] and [[subgroup]]>>
    <<clear [[codeflag]]>>
}
<<main loop>>
END {}
@ 

The actual ``pound-bang'' line is replaced by the \texttt{Makefile}
so that it is correct for each installation.  
Here we define the usual version.
%%
<<pound-bang>>=
#!/usr/bin/gawk --file
@ 

<<generic header>>=
# A gawk filter for auto-indexing a noweb source file.
#
# The user must define two variables, regex and subgroup.
# Regex is a regular expression that matches an indexable 
# line in the source code.  Subgroup is the number of the 
# subgroup in regex that matches the name to be indexed.
#
# For example, to index the defun statements, which typically
# look like
#
#   (defun my-nonsense () ... )
#
# in the lisp file my-lisp.el, you could use
#
#  autodefs.generic \
#    --assign regex='\\(defun ([^ \t()]*)' \
#    --assign subgroup=1 \
#    my-lisp.el
#
@ 

<<generated file warning>>=
# This file was generated from the noweb source file autodefs.nw.
# The source documentation is in autodefs.pdf.
@
<<copyright>>=
# Copyright (c) 2005-2015 by Joseph S. Riel.  All rights reserved.
@ 


\subsection{In the Beginning}
\label{sec:beginning}

First we need to check that the variables
[[regex]] and [[subgroup]] have been assigned.
If not, then raise an error and abort.

<<check for [[regex]] and [[subgroup]]>>=
if (!regex || !subgroup) {
    print "awk variables 'regex' and 'subgroup' not assigned" > "/dev/stderr"
    exit 1
}
@ %def regex subgroup


Set [[codeflag]] [[false]].
This flag is [[true]] when [[awk]] is processing a line in a code section.  
It does not need to be initialized [[false]] 
because the default value of an [[awk]] variable is [[0]], which corresponds to [[false]];
however, doing so is clearer.
%%
<<clear [[codeflag]]>>=
codeflag = <<false>>
@ %def codeflag


\subsection{The Main Loop}
\label{sec:main-loop}


<<main loop>>=
<<if changing section, toggle [[codeflag]]>>
<<if not in a code section, pass-thru>>
<<if no index in line, pass-thru>>
{ <<insert index statement into stream>>
  <<print original line>>
}
@ 


\subsection{Tracking the Code Section}
\label{sec:track-code-sect}


A line starting with \lit{[[@begin code]]} or \lit{[[@end code]]}
indicates the beginning or end of a code section, respectively.  
Use this to toggle [[codeflag]].
Print the line and process the next line.
%%
<<if changing section, toggle [[codeflag]]>>=
($0 ~ /^@(begin|end) code /) {
    codeflag = !codeflag
    {print;next}
}
@

<<if not in a code section, pass-thru>>=
!codeflag {print;next}
@ 

<<if no index in line, pass-thru>>=
!match($0, regex, arr) {print;next}
@ 

\subsection{Indexing a Function Definition}

Insert the \noweb statement that indexes
the symbol into the output stream.
%%
<<insert index statement into stream>>=
print "@index defn", arr[subgroup]
@ 
%""


\subsection{Print the Original Line}
\label{sec:print-modified-line}

%%
<<print original line>>=
print
@ 

\subsection{Miscellaneous}
\label{sec:miscellaneous}


<<not in a code section>>=
!codeflag
@ 
<<true>>=
1
@ 
<<false>>=
0
@ 

\section{Elisp Filter}

<<autodefs.elisp>>=
<<pound-bang>>
<<elisp header>>
<<generated file warning>>
<<copyright>>
BEGIN {
  <<clear [[codeflag]]>>
  <<assign elisp [[regex]] and [[subgroup]]>>
}
<<main loop>>
END {}
@ 

<<elisp header>>=
# An awk filter for auto-indexing an Elisp noweb source file.
@ 


\subsection{Regular Expression}
\label{sec:elisp:regular-expression}

<<assign elisp [[regex]] and [[subgroup]]>>=
regex = "<<elisp: indexable line regex>>"
subgroup = <<elisp name group>>
@ 

While it is not a requirement that a 
[[defun]], [[defvar]], or [[defconst]] statement
be indented flush-left, in practice it is.
%
<<elisp: indexable line regex>>=
<<noweb code line regex>><<elisp regex>>
@

<<elisp regex>>=
\(def(<<def-options>>|ine-(<<define-options>>))[ \t](<<elisp name regex>>)
@

<<elisp name group>>=
3
@ 

<<def-options>>=
un|var|const|group|alias|subsubst|macro|custom|advice|image
@ 

<<define-options>>=
minor-mode|derived-mode|abbrev|category|prefix-command|key-after
@

The \noweb [[markup]] filter 
prefices each code line with the string \lit{@text }.
%%
<<noweb code line regex>>=
^@text[ ]
@

%%
<<elisp name regex>>=
[^ \t\n()]+
@



\section{Maple Filter}

<<autodefs.maple>>=
<<pound-bang>>
<<maple header>>
<<generated file warning>>
<<copyright>>
BEGIN {
  <<clear [[codeflag]]>>
  <<assign maple [[regex]] and [[subgroup]]>>
}
<<main loop>>
END {}
@ 


<<maple header>>=
# An awk filter for auto-indexing a Maple noweb source file.
@ 

\subsection{Regular Expression}
\label{sec:maple:regular-expression}

<<assign maple [[regex]] and [[subgroup]]>>=
regex = "<<maple: indexable line regex>>"
subgroup = <<maple name group>>
@ 

<<maple: indexable line regex>>=
<<noweb code line regex>><<maple regex>>
@

<<maple regex>>=
<<maple name regex>><<optional type>><<ows>>:=<<ows>>(proc|module)\(
@ 

<<maple name group>>=
1
@ 


%%
<<maple name regex>>=
(<<maple symbol regex>>(<<maple index regex>>)
@
<<maple symbol regex>>=
(<<maple normal symbol regex>>|<<maple backquoted regex>>)
@
<<maple normal symbol regex>>=
[a-zA-Z_][a-zA-Z_0-9]*
@
<<maple backquoted regex>>=
`[^`]*`
@
<<maple index regex>>=
\[[^\[\]]*\]
@
%""

<<optional type>>=
(<<ows>>::<<ows>><<maple normal symbol regex>>)?
@

\subsubsection{White Space}
\label{sec:white-space}

Optional white space.
<<ows>>=
[ \t]*
@

Mandatory white space.
<<mws>>=
[ \t]+
@


\section{Matlab Filter}
\label{sec:matlab-filter}

<<autodefs.matlab>>=
<<pound-bang>>
<<matlab header>>
<<generated file warning>>
<<copyright>>
BEGIN {
  <<clear [[codeflag]]>>
  <<assign matlab [[regex]] and [[subgroup]]>>
}
<<main loop>>
END {}
@ 

<<matlab header>>=
# An awk filter for auto-indexing a Matlab noweb source file.
@ 

\subsection{Regular Expression}
\label{sec:matlab:regular-expression}

<<assign matlab [[regex]] and [[subgroup]]>>=
regex = "<<matlab: indexable line regex>>"
subgroup = <<matlab subgroup>>
@ 

<<matlab: indexable line regex>>=
<<noweb code line regex>><<matlab regex>>
@

<<matlab regex>>=
function[ \t][^=]+=<<ows>>(<<matlab function name regex>>)
@

<<matlab function name regex>>=
[a-zA-Z][a-zA-Z_0-9]*
@

<<matlab subgroup>>=
1
@ 

\section{Python Filter}
\label{sec:python-filter}

<<autodefs.python>>=
<<pound-bang>>
<<python header>>
<<generated file warning>>
<<copyright>>
BEGIN {
  <<clear [[codeflag]]>>
  <<assign python [[regex]] and [[subgroup]]>>
}
<<main loop>>
END {}
@ 

<<python header>>=
# An awk filter for auto-indexing a Python noweb source file.
@ 

\subsection{Regular Expression}
\label{sec:python:regular-expression}

<<assign python [[regex]] and [[subgroup]]>>=
regex = "<<python: indexable line regex>>"
subgroup = <<python subgroup>>
@ 

<<python: indexable line regex>>=
<<noweb code line regex>><<python regex>>
@

<<python regex>>=
def<<mws>>(<<python function name regex>>)
@

The Python reference manual specifies that an identifier
must start with a letter or underscore.
Additional characters may be letters, digits, or underscores.
%%
<<python function name regex>>=
[a-zA-Z_][a-zA-Z_0-9]*
@

<<python subgroup>>=
1
@ 

\addcontentsline{toc}{section}{References}
\bibliographystyle{plain}
\bibliography{papers}


\addcontentsline{toc}{section}{Chunks}
\section*{Chunks} 
\nowebchunks

\addcontentsline{toc}{section}{Index}
\section*{Index}
\nowebindex



\end{document}
